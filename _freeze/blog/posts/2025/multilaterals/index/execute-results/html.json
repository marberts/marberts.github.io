{
  "hash": "b908fe5cef61325d1faba822ee83c117",
  "result": {
    "engine": "knitr",
    "markdown": "---\ntitle: \"Making big multilateral indexes fast\"\ndate: \"2025-11-24\"\ncategories:\n  - Performance\n  - Index numbers\n  - R\ndescription: Multilateral price indexes that use large volumes of transaction data can be challening to compute. I show some tricks to calculate big indexes fast.\ndoi: 10.59350/c2v2f-rnj27\n---\n\nMultilateral price indexes are often used to measure the evolution of prices over time when there are large volumes of transaction data, such as retail scanner data or housing data. The main challenge with computing multilateral indexes with large amounts of data is that these indexes often depend on a matrix where the dimensions are at least as large as the number of products. Lots of data means lots of different products, which in turns means making quite large matrices. Indeed, assuming these matrices are stored as 64-bit floats (more on that below), *at least* $8k^2$ bytes of memory are needed just to store one of these matrices with $k$ products---with, say, 100,000 products, that's *at least* 80 GB of memory before doing any computations. Effectively computing these indexes requires a way to reduce the dimensions of these matrices.\n\n## Weighted time product dummy\n\nLet's start with the WTPD index. This index is recovered from the coefficient on a set of time-dummy variables in a weighted log-linear regression model with a dummy variable for each product [e.g., @diewert2022, eq. 9]. Fitting this model is impractical with many products---with $n$ observations for $k$ products over $t$ time periods, the design matrix is a $n \\times (k + t - 1)$ matrix and will consume at least $8(k + t - 1)^2$ bytes of memory. Fortunately, only the coefficients on the time-dummy variables are required to make the index and so the product-dummy variables can be removed by treating them as fixed effects and demeaning the regression equation [@wooldridge2002, section 10.5]. Now the design matrix has only $t - 1$ columns and, as $t$ is usually much smaller than $k$, will consume far less memory.\n\nLet's consider a example. We'll start with a function to make (unbalanced) transaction data for a collection of products over time.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nset.seed(1552443)\n\nmake_prices <- function(products, periods, frac = 0.1) {\n  res <- data.frame(\n    product = as.factor(seq_len(products)),\n    time = as.factor(rep(seq_len(periods), each = products)),\n    price = rlnorm(products * periods),\n    quantity = runif(products * periods)\n  )\n  res[-sample(nrow(res), frac * nrow(res)), ]\n}\n\nhead(make_prices(10, 13))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n  product time     price  quantity\n2       2    1 1.4944618 0.2978414\n3       3    1 0.6778284 0.9263743\n5       5    1 1.2611687 0.3008513\n7       7    1 0.7996127 0.9532272\n8       8    1 0.2138277 0.4409094\n9       9    1 1.9830544 0.9422246\n```\n\n\n:::\n:::\n\n\nWe'll also make a function to take these data and construct the WTPD index from a fixed-effects model with the `{fixest}` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwtpd_index <- function(prices) {\n  prices <- prices |>\n    dplyr::group_by(time) |>\n    dplyr::mutate(w = gpindex::scale_weights(price * quantity))\n\n  mdl <- fixest::feols(\n    log(price) ~ time | product,\n    data = prices,\n    weights = ~w\n  )\n\n  exp(coef(mdl))\n}\n```\n:::\n\n\nNow let's build a WTPD index with data for 100,000 products over 25 time periods. Doing this with a regular linear model, where each product has its own dummy variable, would require 1.8 TB of memory to just store the design matrix, making it impractical to calculate. Using a fixed-effects model to recover the WTPD index can be done without issue on any decent laptop.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nprice_data <- make_prices(1e5, 25)\n\nbench::mark(fixest = wtpd_index(price_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 fixest        4.08s    4.08s     0.245    2.77GB    0.980\n```\n\n\n:::\n:::\n\n\nNote that this is generally much faster than the routine for making the WTPD index in the excellent `{IndexNumR}` package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nwtpd_index2 <- function(prices, window) {\n  # IndexNumR expects these to be integers.\n  prices[c(\"time\", \"product\")] <- lapply(\n    prices[c(\"time\", \"product\")],\n    as.integer\n  )\n  res <- IndexNumR::WTPDIndex(\n    prices,\n    \"price\",\n    \"quantity\",\n    \"time\",\n    \"product\",\n    window = window\n  )\n  as.numeric(res[-1])\n}\n\nprice_data <- make_prices(50, 25)\n\nbench::mark(\n  fixest = unname(wtpd_index(price_data)),\n  IndexNumR = wtpd_index2(price_data, 25)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 fixest        9.4ms  10.31ms    94.5      1.51MB     3.94\n2 IndexNumR     3.81s    3.81s     0.263  102.15MB     7.62\n```\n\n\n:::\n:::\n\n\n## Geary-Khamis index\n\nThe GK index is another multilateral index that's often written as a function of a large matrix. Following @diewert2022, the GK index can be written as a function of two $k \\times k$ matrices. One of these matrices is diagonal, so it can be handled efficiently, but the other is usually dense (unless product imbalanced is really bad) and is impractical to store in memory. Using the same data as with the WTPD index, it would require 80 GB of memory to just store this matrix.\n\nAn alternative approach [@balk2008, pp. 245-246] expresses the GK index as a function of three $t \\times t$ matrices. With the same data as before, this now requires only 15 KB of memory. Here is relatively fast function to implement this approach.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' Intertemporal Geary-Khamis index\n#'\n#' Make a multilateral Geary-Khamis price index.\n#'\n#' @param p A numeric vector of prices.\n#' @param q A numeric vector of quantities.\n#' @param period A factor, or something that can be coerced into one, that\n#'   gives the corresponding time period for each element in `p` and\n#'   `q`. The ordering of time periods follows the levels of `period`\n#'   to agree with [`cut()`][cut.Date].\n#' @param product A factor, or something that can be coerced into one, that\n#'   gives the corresponding product identifier for each element in `p` and\n#'   `q`.\n#' @param na.rm Should missing values be removed? By default they are not.\n#'\n#' @returns\n#' A numeric vector of period-over-period price indexes.\n\nfast_gk <- function(p, q, period, product, na.rm = FALSE) {\n  period <- as.factor(period)\n  product <- as.factor(product)\n\n  qs <- unsplit(lapply(split(q, product), gpindex::scale_weights), product)\n  attributes(product) <- NULL # faster to match on numeric codes\n  ux <- unique(product)\n  product <- lapply(\n    split(product, period),\n    \\(x) match(ux, x, incomparables = NA)\n  )\n\n  v <- Map(`[`, split(p * q, period), product)\n  qs <- Map(`[`, split(qs, period), product)\n\n  n <- nlevels(period)\n  # Make the matrices from pp. 245-246 of Balk (2008) to build the quantity\n  # index, then deflate.\n  m <- vector(\"list\", n)\n  for (i in seq_along(m)) {\n    m[[i]] <- vapply(\n      qs,\n      \\(qs) sum(qs * gpindex::scale_weights(v[[i]]), na.rm = na.rm),\n      numeric(1L)\n    )\n  }\n  e <- diag(n)\n  r <- cbind(rep.int(1, n), matrix(0, n, n - 1))\n  q <- solve(do.call(rbind, m) - e + r)[1L, ]\n  v <- vapply(v, sum, numeric(1L), na.rm = na.rm)\n  # Return the period-over-period index.\n  v[-1L] / v[-length(v)] / (q[-1L] / q[-length(q)])\n}\n```\n:::\n\n\nAs with the WTPD index, any decent laptop can compute this index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngk_index <- function(prices) {\n  fast_gk(\n    prices$price,\n    prices$quantity,\n    prices$time,\n    prices$product,\n    na.rm = TRUE\n  )\n}\n\nprice_data <- make_prices(1e5, 25)\n\nbench::mark(fast_gk = gk_index(price_data))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 fast_gk       1.39s    1.39s     0.717     819MB    0.717\n```\n\n\n:::\n:::\n\n\nIt is similarly non-trivial to make an index of this size with `{IndexNumR}`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ngk_index2 <- function(prices, window) {\n  prices[c(\"time\", \"product\")] <- lapply(\n    prices[c(\"time\", \"product\")],\n    as.integer\n  )\n  res <- IndexNumR::GKIndex(\n    prices,\n    \"price\",\n    \"quantity\",\n    \"time\",\n    \"product\",\n    window = window\n  )\n  as.numeric(res[-1] / res[-length(res)])\n}\n\nprice_data <- make_prices(1000, 25)\n\nbench::mark(\n  fast_gk = unname(gk_index(price_data)),\n  IndexNumR = gk_index2(price_data, 25)\n)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 2 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 fast_gk      7.24ms   7.66ms   124.       8.15MB    2.00 \n2 IndexNumR     1.33s    1.33s     0.751  332.21MB    0.751\n```\n\n\n:::\n:::\n\n\n## Repeat sales\n\nThe repeat-sales indexes listed by @shiller1991 are a type of multilateral index usually found in the housing economics literature. Like the WTPD index, they come from linear models and suffer from the same large design matrices. The geometric repeat-sales index is like the WTPD index, although usually with a much longer time horizon, except that it uses the first-difference transformation to sweep out the product fixed effects instead of the within-group transformation. The arithmetic repeat-sales index is more complicated as it comes from an IV estimator and its not obvious, at least to me, how the matrices for this index can be made smaller.\n\nInstead of reducing the dimensionality of the repeat-sales matrices, these matrices are naturally sparse when products sell infrequently (like housing) and can be stored as sparse matrices. Let's adapt the vignette from my `{rsmatrix}` package to see this in action with some data for 5 million house sales over 30 years.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nperiods <- seq(as.Date(\"2000-01-01\"), as.Date(\"2029-12-31\"), \"day\")\n\nprices <- data.frame(\n  sale = sample(periods, 5e6, TRUE),\n  property = factor(sprintf(\"%06d\", sample(1:1e6, 5e6, TRUE))),\n  price = rlnorm(5e6)\n) |>\n  dplyr::mutate(period = cut(sale, \"month\"))\n\nsales_pairs <- rsmatrix::rs_pairs(prices$sale, prices$property)\nprices[c(\"price_prev\", \"period_prev\")] <- prices[\n  sales_pairs,\n  c(\"price\", \"period\")\n]\n\nprices <- prices |>\n  dplyr::mutate(\n    holding_period = as.numeric(period) - as.numeric(period_prev)\n  ) |>\n  dplyr::filter(holding_period > 2)\n\nhead(prices)\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n        sale property     price     period price_prev period_prev\n1 2016-05-11   627686 0.7705151 2016-05-01  0.1878927  2014-06-01\n2 2029-07-22   992771 0.2366689 2029-07-01  0.4822262  2026-10-01\n3 2011-07-17   925847 0.1712451 2011-07-01  0.5992709  2003-05-01\n4 2013-03-28   337973 0.1540939 2013-03-01  0.9106525  2002-11-01\n5 2008-04-22   295262 0.3274417 2008-04-01  0.2760829  2003-10-01\n6 2015-12-27   038822 2.2174534 2015-12-01  1.7673652  2010-11-01\n  holding_period\n1             23\n2             33\n3             98\n4            124\n5             54\n6             61\n```\n\n\n:::\n:::\n\n\nWe can now build a generator to make the sparse repeat-sales matrices. If these were dense matrices they would consume 22.1 GB of memory. This isn't nearly as bad as the WTPD or GK indexes, but still enough to make computing these indexes cumbersome. With sparse matrices, however, it is easy to make the repeat-sales index.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrices <- with(\n  prices,\n  rsmatrix::rs_matrix(period, period_prev, price, price_prev, sparse = TRUE)\n)\n\nZ <- matrices(\"Z\")\nX <- matrices(\"X\")\nY <- matrices(\"Y\")\n\nbench::mark(ars = 1 / Matrix::solve(crossprod(Z, X), crossprod(Z, Y)))\n```\n\n::: {.cell-output .cell-output-stdout}\n\n```\n# A tibble: 1 × 6\n  expression      min   median `itr/sec` mem_alloc `gc/sec`\n  <bch:expr> <bch:tm> <bch:tm>     <dbl> <bch:byt>    <dbl>\n1 ars           1.55s    1.55s     0.646       3MB        0\n```\n\n\n:::\n:::\n\n\n## GEKS\n\nLet's conclude by briefly mentioned the GEKS family of multilateral indexes. As with the others, the GEKS depends on a matrix, but it is only a $t \\times t$ matrix and will require very little memory. This makes GEKS indexes somewhat more straightforward to compute than the other popular multilateral indexes.\n\n<details><summary>Session Info</summary>\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n\n```\nR version 4.5.2 (2025-10-31)\nPlatform: x86_64-pc-linux-gnu\nRunning under: Ubuntu 24.04.3 LTS\n\nMatrix products: default\nBLAS:   /usr/lib/x86_64-linux-gnu/blas/libblas.so.3.12.0 \nLAPACK: /usr/lib/x86_64-linux-gnu/lapack/liblapack.so.3.12.0  LAPACK version 3.12.0\n\nlocale:\n [1] LC_CTYPE=en_US.UTF-8       LC_NUMERIC=C              \n [3] LC_TIME=en_US.UTF-8        LC_COLLATE=en_US.UTF-8    \n [5] LC_MONETARY=en_US.UTF-8    LC_MESSAGES=en_US.UTF-8   \n [7] LC_PAPER=en_US.UTF-8       LC_NAME=C                 \n [9] LC_ADDRESS=C               LC_TELEPHONE=C            \n[11] LC_MEASUREMENT=en_US.UTF-8 LC_IDENTIFICATION=C       \n\ntime zone: America/Toronto\ntzcode source: system (glibc)\n\nattached base packages:\n[1] stats     graphics  grDevices utils     datasets  methods   base     \n\nloaded via a namespace (and not attached):\n [1] Matrix_1.7-4        jsonlite_2.0.0      dplyr_1.1.4        \n [4] compiler_4.5.2      rsmatrix_0.2.9      tidyselect_1.2.1   \n [7] Rcpp_1.1.0          yaml_2.3.10         fastmap_1.2.0      \n[10] lattice_0.22-7      R6_2.6.1            generics_0.1.4     \n[13] Formula_1.2-5       knitr_1.50          htmlwidgets_1.6.4  \n[16] tibble_3.3.0        pillar_1.11.1       rlang_1.1.6        \n[19] utf8_1.2.6          xfun_0.54           stringmagic_1.2.0  \n[22] fixest_0.13.2       cli_3.6.5           magrittr_2.0.4     \n[25] digest_0.6.38       grid_4.5.2          IndexNumR_0.6.0    \n[28] sandwich_3.1-1      gpindex_0.6.3       lifecycle_1.0.4    \n[31] nlme_3.1-168        vctrs_0.6.5         bench_1.1.4        \n[34] evaluate_1.0.5      glue_1.8.0          data.table_1.17.8  \n[37] numDeriv_2016.8-1.1 zoo_1.8-14          profmem_0.7.0      \n[40] dreamerr_1.5.0      rmarkdown_2.30      tools_4.5.2        \n[43] pkgconfig_2.0.3     htmltools_0.5.8.1  \n```\n\n\n:::\n:::\n\n</details>\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}